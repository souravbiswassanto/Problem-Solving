{"id":749528282,"lang":"cpp","time":"3 weeks, 1 day","timestamp":1658074588,"status_display":"Accepted","runtime":"55 ms","url":"/submissions/detail/749528282/","is_pending":"Not Pending","title":"K Inverse Pairs Array","memory":"16.3 MB","code":"class Solution {\npublic:\n    int mod=1e9+7;\n    int kInversePairs(int n, int K) {\n        //dp[i][j] denote till i numbers how many jth inversion pair wala permutations are there\n        vector<vector<int>> dp(n+1,vector<int>(K+1,0));\n        dp[0][0]=0;\n        for(int i=1;i<=K;i++){\n            dp[1][i]=0;\n        }\n        for(int i=1;i<=n;i++){\n            dp[i][0]=1;\n        }\n        //now lets say we have N-1 numbers and K inversions and we are adding N to these N-1 numbers\n        //if we add N to the end of the array,no increase in inversions will occur eg ****5\n        //if we add N to the last second postiion of the array 1 inversion will increase so we will tell the remaining N-1 integers to rearrange them \n\t\t//in such a way that they produce K-1 inversions among themselves because I am contributing 1 inversion by being at the second last postiion\n\t\t//eg:***5*(1 inversion increased)\n        //similarly ,if we put N to the last third position we will get our answer in dp[N-1][K-2] eg:**5**(2 inversions increased)\n        //so basically dp[N][K]=dp[N-1][K]+dp[N-1][K-1]+dp[N-1][k-2]+dp[N-1][k-3]+.......dp[N-1][K-(N-1)];\n        //also provided K-(N-1)>=0 at the end in the last term in the formula\n        \n        //but this will give tle\n        //the code will be like\n        /*\n        for(int i=2;i<=n;i++){\n            for(int j=1;j<=k;j++){\n                for(int k=0;k<=i-1;k++){\n                 if(j-k>=0){\n                    dp[i][j]+=d[i][j-k];\n                    dp[i][j]%=mod;\n                  }\n                }\n            }\n        }\n        return dp[N][K];\n        */\n        //now see the **optimization**\n        /*\n\t\tLets say we consider dp[4][6] and dp[4][7],just randomly\n\t\tAplly the formula above,and we will get\n        dp[4][6]=dp[3][6]+dp[3][5]+dp[3][4]+dp[3][3]--------------------->(1)\n        \n        dp[4][7]=dp[3][7]+dp[3][6]+dp[3][5]+dp[3][4]---------------------->(2)\n        \n        //suntract 1 from 2\n        dp[4][7]-dp[4][6]=dp[3][7]-dp[3][3]\n        dp[4][7]=dp[4][6]+dp[3][7]-dp[3][3]\n         //so dp[N][K]=dp[N-1][K]+dp[N][K-1]-dp[N-1][K-1]\n        */\n        for(int i=2;i<=n;i++){\n            for(int j=1;j<=K;j++){\n                dp[i][j]=(dp[i-1][j]+dp[i][j-1])%mod;\n                if(j-i>=0){\n                    dp[i][j]=(dp[i][j]-dp[i-1][j-i]+mod)%mod;\n                }\n            }         \n        }\n        return dp[n][K];\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"k-inverse-pairs-array"}