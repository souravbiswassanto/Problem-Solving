{"id":744917086,"lang":"java","time":"4 weeks","timestamp":1657605709,"status_display":"Accepted","runtime":"286 ms","url":"/submissions/detail/744917086/","is_pending":"Not Pending","title":"Matchsticks to Square","memory":"67.2 MB","code":"import java.util.HashMap;\n\nclass Solution {\n\n    // The memoization cache to be used during recursion.\n    public HashMap<Pair<Integer, Integer>, Boolean> memo;\n\n    // Array containing our matchsticks.\n    public int[] nums;\n\n    // Possible side of our square depending on the total sum of all the matchsticks. \n    public int possibleSquareSide;\n\n    // Default constructor to initialise our memo cache.\n    public Solution() {\n        this.memo = new HashMap<Pair<Integer, Integer>, Boolean>();\n    }\n\n    // Main DP function.\n    public boolean recurse(Integer mask, Integer sidesDone) {\n        int total = 0;\n        int L = this.nums.length;\n\n        // The memo key for this recursion\n        Pair<Integer, Integer> memoKey = new Pair(mask, sidesDone);\n\n        // Find out the sum of matchsticks used till now.\n        for(int i = L - 1; i >= 0; i--) {\n            if ((mask&(1 << i)) == 0) {\n                total += this.nums[L - 1 - i];\n            }\n        }\n\n        // If the sum if divisible by our square's side, then we increment our number of complete sides formed variable.\n        if (total > 0 && total % this.possibleSquareSide == 0) {\n            sidesDone++;\n        }\n\n        // Base case.\n        if (sidesDone == 3) {\n            return true;\n        }\n\n\n        // Return precomputed results\n        if (this.memo.containsKey(memoKey)) {\n            return this.memo.get(memoKey);\n        }\n\n        boolean ans = false;\n        int c = total / this.possibleSquareSide;\n\n        // Remaining vlength in the current partially formed side.\n        int rem = this.possibleSquareSide * (c + 1) - total;\n\n        // Try out all remaining options (that are valid)\n        for(int i = L - 1; i >= 0; i--) {\n            if (this.nums[L - 1 - i] <= rem && (mask&(1 << i)) > 0) {\n                if (this.recurse(mask ^ (1 << i), sidesDone)) {\n                    ans = true;\n                    break;\n                }\n            }\n        }\n\n        // Cache the computed results.\n        this.memo.put(memoKey, ans);\n        return ans;\n    }\n\n    public boolean makesquare(int[] nums) {\n\n        // Empty matchsticks.\n        if (nums == null || nums.length == 0) {\n            return false;\n        }\n\n        // Find the perimeter of the square (if at all possible)\n        int L = nums.length;\n        int perimeter = 0;\n        for(int i = 0; i < L; i++) {\n            perimeter += nums[i];\n        }\n\n        int possibleSquareSide =  perimeter / 4;\n        if (possibleSquareSide * 4 != perimeter) {\n            return false;\n        }\n\n        this.nums = nums;\n        this.possibleSquareSide = possibleSquareSide;\n        return this.recurse((1 << L) - 1, 0);\n    }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"matchsticks-to-square"}